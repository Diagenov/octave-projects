lyambda = 0;          %с регуляризацией у меня нелады..
load('ex3data1.mat'); %загружаем картинки циферок

m = size(X, 1);     %тут 5000 картинок
n = size(X, 2) + 1; %картинки 20x20 + столбец единичек

Y = y;                %определяет, какая цифра изображена на картинке (10 - это 0!)
X = [ones(m, 1), X];  %пиксели картинки (1 - черный, 0 - белый)

%случайным образом перемешиваем все картинки
learn = 500;  %сколько возьмем для обучения
rand = randperm(m);
rand1 = rand(1:learn);
rand2 = rand(learn:m);

%первые несколько случайных картинок - для 'обучения'
Xo = X(rand1, :);
Yo = Y(rand1, :);
C = zeros(n, 10);

%остальные - для проверки полученных коэффициентов
X = X(rand2, :);
Y = Y(rand2, :);

%готовое решение для метода оптимизации 'градиентный спуск'..
options = optimset('GradObj', 'on', 'MaxIter', 50);

%итеративно ищем ('обучаем') нужные коэффициенты (их десять штук, как и циферок)
for i = 1:10

  %определяем 'правило' (целевую функцию?) для поиска коэффициентов..
  expression = @(T) (help(T, Xo, (Yo == i), lyambda));
  start = zeros(n, 1);

  %используем готовое решение..
  [c] = fmincg(expression, start, options);
  C(:, i) = c;

end

%для каждой строки находим столбец с максимальным значением (это предполагает, какую цифру представляет данная строка)
[Q, I] = max(X * C, [], 2);

%находим все совпадения с действительностью
Q = (Y == I);
U = accumarray(Q + 1.0, 1);
V = unique(Q - 1.0);

%показывает процент правильно (1) и неправильно (0) распознанных картинок
Q = [0; 1];
Q = [Q, U ./ (m - learn)]




%дальше писал что-то для себя
%чтобы не забыть...

% всего цифр десять: 1, 2, 3, 4, 5, 6, 7, 8, 9, 0
% некоторые из 100 картинок -- для обучения
% остальные картинки -- для проверки
% при обучении мы для каждой цифры получаем свой набор коэффициентов
% перемножим каждый из наборов коэффициентов, определяющие цифры, на картинку
% мы получим распределение вероятности (числа от 0 до 1) для каждой цифры
% например, на картинке девятка
% представляем черный пиксель -- 1, белый -- 0 (серый -- от 0 до 1, то есть шумы)
% картинка представлена матрицей -- выпрямляем её в вектор-столбец
% берём коэффициенты для восьмёрки и умножаем на вектор-столбец картинки
% должны по итогу получить число, стремящееся к нулю (нулевая вероятность)
% теперь, если возьмём коэффициенты для девятки и проделаем всё то же самое
% должны получить число, близкое к единице (полное совпадение)
% имеем в виду, что тут у X есть столбец единичек (может мешать отрисовке картинок)
% predictOneVsAll -- там находится классификация цифр по уже сформированным коэффициентам


